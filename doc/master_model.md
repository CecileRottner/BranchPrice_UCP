# Master problem


## Classes "Master Variables"

For each decomposition type, there is a class representing extended variables generated by column generation :

- for unit/site decomposition : class __Master_Variable__

- for time decompositon : class __MasterTime_Variable__

Theses classes keep a pointer to one SCIP variable, as well as indicators regarding this variable : to which unit/site or time step it corresponds, the subproblem extreme point it stands for (eg: up/down plan for 1 unit) and its cost.

In a double decomposition (unit/site + time), then both Master_Variable and MasterTime_Variable classes will be used to represent extended variables.

## Master_Model (virtual)

Class __Master_Model__ (virtual) contains indicators common to all master problems, regardless of decomposition type.
In particular :
* indicators on the instance solved
* Generated interval up set inequalities indicators (total number, pointers to inequalities)
* Current fractional solution (x_frac)
* Associated dual values (totalDualCostList)
* Counter of pricing iterations

Pure virtual methods :
- computeFracSol : from extended variables lambda, computes solution in original variables (depends on the type of decomposition chosen)
- discarVar(constraint) : "constraint" can be seen as a branching constraint. Function discardVar will set to 0 in the model the coeficients of lambda variables which does not satisfy this constraint.
- restoreVar(constraint) : reverse operation, enables to restore previously discarded variables lambdas in the master


## Classes inherited from Master_Model


 Classes inherited from Master_Model work similarly. Each corresponds to a given decomposition structure (unit/site, time, double)
 
 They both contain the following indicators, depending on the decomposition type : 
 
* pointers to all dualized constraints
* pointers to convexity constraints on extended variables
* list of master variables generated
* potential additional variables (non extended) used in the master problem, eg: start-up variable u in the time decomposition.

Methods :
* InitScipMasterModel : initializes the constraints of the master model
* initMasterVariable : adds initial lambda variables (computed with a primal heuristic) to the master model 
* createColumns : from a solution x (given in original variables), creates corresponding lambda variables and adds them to the master (using initMasterVariable)
* addCoefToConstraint(lambda) : after a new variable lambda is generated, this function updates master constraints to add lambda in them with the right coeficient.


### MasterSite_Model

Class MasterSite_Model represents the master problem of a unit/site decomposition.

Various decomposition options are handled through MasterSite_Model : classical unit or site decomposition, start-up decomposition, residual demand decomposition, power decomposition...

See [README](../README.md) or Chapter 8 of https://hal.archives-ouvertes.fr/tel-02052101/document for more details on these options.


### MasterTime_Model

Class MasterTime_Model represents the master problem of a time decomposition.

### MasterDouble_Model


Class MasterTime_Model represents the master problem of a double decomposition : unit/site + time decomposition.


 




